(in-package #:ctype)

(defmethod ctypep (client (object complex) (ct ccomplex))
  (complex-ucptp client object (ccomplex-ucpt ct)))
(defmethod ctypep (client (object t) (ct ccomplex))
  (declare (ignore client))
  nil)

(defmethod subctypep (client (ct1 ccomplex) (ct2 ccomplex))
  (declare (ignore client))
  (values (equal (ccomplex-ucpt ct1) (ccomplex-ucpt ct2)) t))

(defmethod ctype= (client (ct1 ccomplex) (ct2 ccomplex))
  (declare (ignore client))
  (values (equal (ccomplex-ucpt ct1) (ccomplex-ucpt ct2)) t))

(defmethod disjointp (client (ct1 ccomplex) (ct2 ccomplex))
  (declare (ignore client))
  (let ((ucpt1 (ccomplex-ucpt ct1)) (ucpt2 (ccomplex-ucpt ct2)))
    (cond ((eq ucpt1 '*) (values t t))
          ((eq ucpt2 '*) (values t t))
          (t (values (equal ucpt1 ucpt2) t)))))
(defmethod conjointp (client (ct1 ccomplex) (ct2 ccomplex))
  (declare (ignore client))
  (values nil t))

(defmethod cofinitep (client (ct ccomplex))
  (declare (ignore client))
  (values nil t))

(defmethod conjoin/2 (client (ct1 ccomplex) (ct2 ccomplex))
  (declare (ignore client))
  (let ((ucpt1 (ccomplex-ucpt ct1)) (ucpt2 (ccomplex-ucpt ct2)))
    (cond ((eq ucpt1 '*) ct2)
          ((eq ucpt2 '*) ct1)
          ((equal ucpt1 ucpt2) ct1)
          (t (bot)))))

(defmethod disjoin/2 (client (ct1 ccomplex) (ct2 ccomplex))
  (declare (ignore client))
  (let ((ucpt1 (ccomplex-ucpt ct1)) (ucpt2 (ccomplex-ucpt ct2)))
    (cond ((eq ucpt1 '*) ct1)
          ((eq ucpt2 '*) ct2)
          ((equal ucpt1 ucpt2) ct1)
          (t nil))))

(defmethod subtract (client (ct1 ccomplex) (ct2 ccomplex))
  (declare (ignore client))
  (let ((ucpt1 (ccomplex-ucpt ct1)) (ucpt2 (ccomplex-ucpt ct2)))
    (cond ((eq ucpt2 '*) (bot))
          ((eq ucpt1 '*) nil)
          ((equal ucpt1 ucpt2) (bot))
          (t ct1))))

(defmethod unparse ((ct ccomplex))
  (let ((ucpt (ccomplex-ucpt ct)))
    (if (eq ucpt '*)
        'complex
        `(complex ,ucpt))))
